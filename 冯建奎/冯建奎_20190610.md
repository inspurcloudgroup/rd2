C++指针
指针是一个特殊的变量，里面存储的数值被解释为内存里的一个地址；
指针的类型，指针所指向的类型，指针的值或者指针所指向的内存区，指针本身所占据的内存区。
指针类型：只要把指针声明语句里的指针名字去掉，剩下的部分就是这个指针的类型。
int *ptr; //指针的类型是int *  
char *ptr; //指针的类型是char *  
int **ptr; //指针的类型是 int **  
int (*ptr)[3]; //指针的类型是 int(*)[3]  
int *(*ptr)[4]; //指针的类型是 int *(*)[4] 
指针所指向的类型：把指针声明语句中的指针名字和名字左边的指针声明符*去掉，剩下的就是指针所指向的类型。
int *ptr; //指针所指向的类型是int  
char *ptr; //指针所指向的的类型是char  
int **ptr; //指针所指向的的类型是 int *  
int (*ptr)[3]; //指针所指向的的类型是 int()[3]  
int *(*ptr)[4]; //指针所指向的的类型是 int *()[4] 
指针的值：指针本身存储的值，这个值将被编译器当作一个地址，而不是一个一般的数指。
指针本身所占据的内存区：sizeof(指针类型)
指针的算术运算：
指针加上或则减去一个整数，其所指向的内存发生变化  如：ptr ++
指针运算符&和*
&:取地址运算符，&a表示一个指针，指针所指向的类型是a的类型。如：ptr = &a；
*：间接运算符，*ptr表示一个变量，ptr为指针变量，如：*ptr = a;
指针表达式：一个表达式的最后结果如果是一个指针，那么这个表达式就是指针表达式
如：ptr++
数组与指针的关系：
数组的数组名可以看作指针，则*array表示array[0],*(array+3)=array[3]
如果对声明数组的语句不太明白的话，请参阅我前段时间贴出的文章<<如何理解c和c++的复杂类型声明>>。 数组的数组名其实可以看作一个指针。看下例：  

例八：  
int array[10]={0,1,2,3,4,5,6,7,8,9},value;  
...  
...  
value=array[0];//也可写成：value=*array;  
value=array[3];//也可写成：value=*(array+3);  
value=array[4];//也可写成：value=*(array+4);  



上例中，一般而言数组名array代表数组本身，类型是int [10]，但如果把array看做指针的话，它指向数组的第0个单元，类型是int *，所指向的类型是数组单元的类型即int。因此*array等于0就一点也不奇怪了。同理，array+3是一个指向数组第3个单元的指针，所以*(array+3)等于3。其它依此类推。 

例九：  

char *str[3]={  
"Hello,this is a sample!",  
"Hi,good morning.",  
"Hello world"  
};  
char s[80]；  
strcpy(s,str[0]);//也可写成strcpy(s,*str);  
strcpy(s,str[1]);//也可写成strcpy(s,*(str+1));  
strcpy(s,str[2]);//也可写成strcpy(s,*(str+2));  


上例中，str是一个三单元的数组，该数组的每个单元都是一个指针，这些指针各指向一个字符串。把指针数组名str当作一个指针的话，它指向数组的第0号单元，它的类型是char**，它指向的类型是char *。

*str也是一个指针，它的类型是char*，它所指向的类型是char，它指向的地址是字符串"Hello,this is a sample!"的第一个字符的地址，即'H'的地址。 str+1也是一个指针，它指向数组的第1号单元，它的类型是char**，它指向的类型是char *。 

*(str+1)也是一个指针，它的类型是char*，它所指向的类型是char，它指向"Hi,good morning."的第一个字符'H'，等等。  

下面总结一下数组的数组名的问题。声明了一个数组TYPE array[n]，则数组名称array就有了两重含义：第一，它代表整个数组，它的类型是TYPE [n]；第二，它是一个指针，该指针的类型是TYPE*，该指针指向的类型是TYPE，也就是数组单元的类型，该指针指向的内存区就是数组第0号单元，该指针自己占有单独的内存区，注意它和数组第0号单元占据的内存区是不同的。该指针的值是不能修改的，即类似array++的表达式是错误的。 

在不同的表达式中数组名array可以扮演不同的角色。  

在表达式sizeof(array)中，数组名array代表数组本身，故这时sizeof函数测出的是整个数组的大小。  

在表达式*array中，array扮演的是指针，因此这个表达式的结果就是数组第0号单元的值。sizeof(*array)测出的是数组单元的大小。  

表达式array+n（其中n=0，1，2，....。）中，array扮演的是指针，故array+n的结果是一个指针，它的类型是TYPE*，它指向的类型是TYPE，它指向数组第n号单元。故sizeof(array+n)测出的是指针类型的大小。 

例十：  
int array[10];  
int (*ptr)[10];  
ptr=&array;  

上例中ptr是一个指针，它的类型是int (*)[10]，他指向的类型是int [10]，我们用整个数组的首地址来初始化它。在语句ptr=&array中，array代表数组本身。 

本节中提到了函数sizeof()，那么我来问一问，sizeof(指针名称)测出的究竟是指针自身类型的大小呢还是指针所指向的类型的大小？答案是前者。例如：
int (*ptr)[10];  

则在32位程序中，有：  
sizeof(int(*)[10])==4  
sizeof(int [10])==40  
sizeof(ptr)==4  
实际上，sizeof(对象)测出的都是对象自身的类型的大小，而不是别的什么类型的大小。


学习心得
对指针的理解：
int *ptr     *ptr是一个变量
int **ptr     **ptr是一个变量，*ptr是一个指针变量，ptr是一个指向指针变量的指针变量
int (*ptr)[3]  (*ptr)[3]是一个变量
int *(*ptr)[4]  *(*ptr)[4]是一个变量
