# 简介

## 在 GitHub 上创建仓库

首先，打开 [GitHub](https://github.com/) 注册个人账户并登录。点击 `New repository` 创建新的仓库：

![创建个人仓库](assets/1558577197338.png)

打开页面如下图所示，填入相关信息。注意下图紫色框中有两个下拉按钮，左边的用来选择忽略文件，右边的用来选择所属协议，这两项可以不选，后面的课程会讲到。

![1558577245849](assets/1558577245849.png)点击绿色按钮创建新的仓库，成功后自动跳转到新建仓库的主页面，如下图所示：

![创建完成](assets/1558577281241.png)

## 克隆仓库到本地：

以下的操作在fork的岗前培训仓库完成。

### 复制链接

![复制仓库链接](assets/1558577648033.png)

### 克隆

![克隆到本地](assets/1558577757973.png)

### 查看克隆结果

![查看结果](assets/1558577910443.png)

![查看](assets/1558577953919.png)

## 初始化一个本地仓库

### 初始化后并取消本地仓库

![1558579742368](assets/1558579742368.png)

# Git 基础操作

## Git仓库的三大区域

Git 本地仓库有三大区域：工作区、暂存区、版本区。

![Git仓库的三大区域](assets/wm.png)

## 一次完整的修改、提交、推送操作

进入仓库主目录，执行 `git status` 查看整个仓库的状态：（此处因为已经修改过）

![1558580091477](assets/1558580091477.png)

## 对工作区进行修改

![1558580265544](assets/1558580265544.png)

## 添加到暂存区以及撤销修改

![1558580365900](assets/1558580365900.png)

![1558580355971](assets/1558580355971.png)

如果对多个文件或目录进行了增删改，可以使用 `git add .`命令全部添加到暂存区。

注意这里有个概念，当我们修改了工作区，`git add` 命令是将这些修改添加到暂存区，暂存区记录的只是修改。如果要撤销暂存区的修改怎么办？根据上图的提示，执行 `git reset -- [文件名]` 或者 `git rm --cached [文件名]` 命令即可：![1558580479307](assets/1558580479307.png)

上图的命令，如果省略最后的文件名，把命令写成 `git reset --` 即可把暂存区的全部修改撤销。

 `git diff`，它可以用来查看工作区被跟踪的文件的修改详情

![1558580864517](assets/1558580864517.png)

使用 `git diff --cached` 查看暂存区的全部修改：

![1558581018000](assets/1558581018000.png)

## 查看提交历史

执行 `git commit` 命令把暂存区的修改提交到版本区，生成一个新的版本。

命令 `git log`，它用来查看版本区的提交历史记录。此命令也会跳到新页面，如下图所示：

![1558581138606](assets/1558581138606.png)

关于查看提交历史记录的命令，有些常用的选项介绍一下：

- `git log [分支名]` 查看某分支的提交历史，不写分支名查看当前所在分支
- `git log --oneline` 一行显示提交历史
- `git log -n` 其中 n 是数字，查看最近 n 个提交
- `git log --author [贡献者名字]` 查看指定贡献者的提交记录
- `git log --graph` 图示法显示提交历史

## 配置个人信息

（此处用处不大，就没进行本地配置）

接下来需要对 Git 进行一些本地配置：

- `user.email`：写入你自己注册 GitHub 账号的邮箱
- `user.name`：你自己的 GitHub 账号名字

这两个命令设置你的身份信息如下图。`git config -l` 可以查看配置信息（就不展示截图了）：

![此处输入图片的描述](assets/wm-1558581229893.png)

完成后，系统自动生成 Git 的配置文件，就是家目录中的隐藏文件 `.gitconfig` ：

![此处输入图片的描述](assets/wm-1558581230236.png)

上图所示的配置文件也是可以直接手动修改。

## 提交暂存区的修改

### 提交

现在执行 `git commit` 命令生成一个新的提交，一个必须的选项 `-m` 用来提供该提交的备注：

![1558581480349](assets/1558581480349.png)

![1558581492132](assets/1558581492132.png)

![1558581501624](assets/1558581501624.png)

![1558581509860](assets/1558581509860.png)

提交后，暂存区的修改被清空，执行 `git log` 查看提交记录，红色框中的十六进制序列号就是提交版本号，这是很重要的信息，每个提交都有自己单独的版本号，就像公民身份证号一样：

![1558581591970](assets/1558581591970.png)

默认为时间倒叙排列，若是需要正序排列信息，则需要 `git log --reverse` 命令。

### 查看所有分支信息

命令 `git branch -avv`，它用来查看全部分支信息：

![1558581695728](assets/1558581695728.png)

上图有三行信息，依次说明:

- 第一行，开头的星号表示当前所在分支，绿色的 master 是分支名，之所以是绿色，也是因为它是当前所在分支。后面第二项是版本号，第三项中括号里面蓝色的字，表示此分支跟踪的远程分支的名字，当然啦，这也是克隆远程仓库到本地时的默认设置 -- 创建 master 分支并自动跟踪远程同名分支；冒号后面黑色文字表示本地分支领先其跟踪的远程分支一个提交。最后一项是提交时填写的备注信息。

- 第二行，是 Git 指针信息，它指向远程仓库的 master 分支，这行信息暂不重要。

- 第三行，远程分支信息，详见第一行的解释。

  （相对不推荐）在执行 `commit` 命令时，再介绍一个我并不推荐的选项 `-a` ，它的作用是将未添加到暂存区的修改，也就是工作区的修改也一并提交，但会略过未被跟踪的文件，比如新建文件 one.txt，此命令的完整格式：`git commit -am xxxxx` 。

  谨慎的做法是按照前文的顺序，修改工作区 - 提交到暂存区 - 随时使用 `git status` 查看仓库状态 - 将暂存区的修改提交到版本区生成一次新的提交。

### 推送到远程仓库

最后一个环节，将本地新增的提交推送到 GitHub 远程仓库中，命令是 `git push`，后面不需要任何选项和参数，此命令会把本地仓库 master 分支上的新增提交推送到远程仓库的同名分支上，因为当前所在的分支就是 master，而且上文提到，它已经跟踪了远程仓库的同名分支：

![1558582093449](assets/1558582093449.png)

![1558582140453](assets/1558582140453.png)

推送成功后执行 `git branch -avv` 查看分支情况：![1558582207848](assets/1558582207848.png)

![1558582312507](assets/1558582312507.png)

本地和远端一致。

以上就是一次完整的修改 - 提交 - 推送操作。一次推送中可以包含多个 `git commit` 操作，也就是多个提交可以一起推送。

## 版本回退

如果发现文件内容有误，怎么做？可以修改此文件然后再次添加到暂存区、提交、推送，也可以撤销最近一次提交，修改文件后重新提交推送。现在使用后一种方法来演示撤销提交的操作流程。

首先执行 `git reset --soft HEAD^` 撤销最近的一次提交，将修改还原到暂存区。`--soft` 表示软退回，对应的还有 `--hard`硬退回，后面会讲到，`HEAD^` 表示撤销一次提交，`HEAD^^` 表示撤销两次提交，撤销 n 次可以简写为 `HEAD~n`。软退回一个提交后执行 `git branch -avv` 命令查看分支信息：

![1558582504002](assets/1558582504002.png)

![1558582479316](assets/1558582479316.png)

版本号已经变化。

![1558582548200](assets/1558582548200.png)

## 处理commit时间线分叉

本地仓库的 master 分支与远程仓库的 origin/master 分支在提交版本上有了冲突，又叫做提交时间线分叉。因为刚才的提交操作不是基于远程仓库 origin/master 分支的最新提交版本，而是撤回了一个版本。这种情况下也是可以将本地 master 分支推送到远程仓库的，需要加一个选项 `-f` ，它是 `--force` 的简写，这就是强制推送：

![1558588763333](assets/1558588763333.png)

## 本地仓库 commit 变化记录

假设此时发现情况不对，之前的那次版本号为 5c04 的提交是正确的，刚才的版本回退操作全都是误操作，怎么办？再次执行一次版本回退吗？当然不需要啦，我们有 `git reflog`命令，它会记录本地仓库所有分支的每一次版本变化。实际上只要本地仓库不被删除，随你怎么折腾，都能回退到任何地方。`reflog` 记录只存在于本地仓库中，本地仓库删除后，记录消失。执行此命令如下图所示：
![1558588908005](assets/1558588908005.png)

怎么回退到指定版本呢？可以直接执行命令 `git reset --hard [版本号]` ，如果记不清版本号，也可以执行 `git reset --hard HEAD@{2}` 命令，其中 `HEAD@{2}` 就是上图第 3 行第 2 列所示，这个命令的意思是回到当前分支最近两次提交版本变化前（此命令在commit之前不要执行，之前就因为此丢失了部分笔记）。

重要的一点，本节全部命令中，只有 `push` 是需要联网执行的，它对远程仓库进行了修改。

# Git 分支操作

## 添加ssh关联授权

终端执行 `ssh-keygen` 命令按几次回车生成公私钥，公私钥存放在家目录下的隐藏目录 `.ssh` 中的两个文件中。

将 `~/.ssh/id_rsa.pub` 文件中的公钥内容复制出来。

然后在 GitHub 网页上添加公钥。

此公钥已添加过，此处略过。

## 为Git命令设置别名

上一节课程中的操作，有些命令的重复度极高，比如 `git status` 和 `git branch -avv` 等，Git 可以对这些命令设置别名，以便简化对它们的使用，设置别名的命令是 `git config --global alias.[别名] [原命令]`，如果原命令中有选项，需要加引号。别名是自定义的，可以随意命名，设置后，原命令和别名具有同等作用。操作如下：

![1558592309788](assets/1558592309788.png)

自己设置的别名要记住，也可以使用 `git config -l` 命令查看配置文件。下面文档中的命令将使用这些别名。

## Git分支管理

### git fetch 刷新本地分支信息

在介绍分支前，先讲解另一个命令`git fetch`，它的作用是将远程仓库的分支信息拉取到本地仓库，注意，仅仅是更新了本地的远程分支信息，也就是执行 `git branch -avv `命令时，查看到的 `remotes` 开头的行的分支信息。

提交完成后，提交数变化

![1558592758916](assets/1558592758916.png)

在实验环境中执行 `git fetch` 命令，然后执行 `git branch -avv` 查看分支信息：

![1558593098005](assets/1558593098005.png)

可以看到，本地分支 master 的版本号无变化，而远程分支已经更新。所以，`fetch` 命令的作用是刷新保存在本地仓库的远程分支信息，此命令需要联网。此时若想使本地 master 分支的提交版本为最新，可以执行 `git pull` 命令来拉取远程分支到本地，`pull` 是拉取远程仓库的数据到本地，需要联网，而由于前面执行过 `git fetch` 命令，所以也可以执行 `git rebase origin/master` 命令来实现 “使本地 master 分支基于远程仓库的 master 分支”，`rebase` 命令在后面还会经常用到，这里只需按部就班操作即可：

可以看到，远程仓库 master 分支、本地仓库的 origin/master 分支、本地仓库的 master 分支已经一致。

### 扩展：git fetch 和git pull 的差别
1、git fetch 相当于是从远程获取最新到本地，不会自动merge，如下指令：

```
　git fetch orgin master //将远程仓库的master分支下载到本地当前branch中
　git log -p master  ..origin/master //比较本地的master分支和origin/master分支的差别
　git merge origin/master //进行合并
```

也可以用以下指令：

```
git fetch origin master:tmp //从远程仓库master分支获取最新，在本地建立tmp分支
git diff tmp //將當前分支和tmp進行對比
git merge tmp //合并tmp分支到当前分支
```

2. git pull：相当于是从远程获取最新版本并merge到本地
```
git pull origin master
```

git pull 相当于从远程获取最新版本并merge到本地。

在实际使用中，git fetch更安全一些。

### 创建新的本地分支

分支在项目开发中作用重大，多人协作时尤其不可或缺。例如一个项目上线了 1.0 版本，研发部门需要开发 1.1、1.2 两个测试版，增加不同的新功能，测试版的代码显然不能在正式版所在的分支上，此时需要新的分支来存放不同版次的代码。再例如实验楼的课程团队在维护课程仓库时，每个人都有各自的分支，在自己的分支上进行修改，然后向 master 分支提 PR（pull request），最后从 master 分支推送到线上。

执行 `git branch [分支名]` 可以创建新的分支：

![1558593505758](assets/1558593505758.png)

此命令创建新分支后并未切换到新分支，还是在 master 分支上，执行 `git checkout [分支名]` 切换分支，`checkout` 也是常用命令，先给它设置别名ch，然后切换分支：

![1558593574330](assets/1558593574330.png)

创建新分支还要手动切换太麻烦，介绍另一个常用的命令 `git checkout -b [分支名]` 创建分支并切换到新分支：

![1558593613480](assets/1558593613480.png)

在哪个分支上创建新分支，新分支的提交记录就与哪个分支一致。新建分支并无跟踪任何远程分支，所以没有 master 分支中的中括号和括号内的蓝色远程分支名。

在dev分支上修改文件。

![1558593816392](assets/1558593816392.png)

## 将新分支中的提交推送至远程仓库

推送正常逻辑当然要推送到远程仓库的同名分支，不过现在远程仓库里只有一个分支`master`：

执行 `git push [主机名] [本地分支名]:[远程分支名]` 即可将本地分支推送到远程仓库的分支中，通常冒号前后的分支名是相同的，如果是相同的，可以省略 `:[远程分支名]`，如果远程分支不存在，会自动创建：

![1558593991297](assets/1558593991297.png)

## 本地分支跟踪远程分支

现在有个问题，当我们再次在 dev1分支上修改并提交，推送到远程仓库时还是要输入上面的那个长长的命令，好不方便。如果能和 master 分支一样跟踪远程同名分支，就可以直接使用 `git push` 命令推送了。有办法的，执行这个命令 `git branch -u [主机名/远程分支名] [本地分支名]` 将本地分支与远程分支关联，或者说使本地分支跟踪远程分支。如果是设置当前所在分支跟踪远程分支，最后一个参数本地分支名可以省略不写。

这个命令的 `-u` 选项是 `--set-upstream` 的缩写。可不可以让本地分支跟踪远程非同名分支呢？可以的，尽管几乎遇不到这种自找麻烦的需求。可不可以撤销本地分支对远程分支的跟踪呢？也是可以的，执行 `git branch --unset-upstream [分支名]` 即可撤销该分支对远程分支的跟踪，同样地，如果撤销当前所在的分支的跟踪，分支名可以省略不写：

![1558594235103](assets/1558594235103.png)

问题又来了，前面的操作是先将本地分支推送到远程仓库，使远程仓库创建新分支，然后再执行命令使本地分支跟踪远程分支，有没有办法在推送时就自动跟踪远程分支呢？有的，在推送的时候，加个 `--set-upstream` 或其简写 `-u` 选项即可。

## 删除远程分支

接下来，介绍一下删除分支的方法。

首先，删除远程分支，使用 `git push [主机名] :[远程分支名]` ，如果一次性删除多个，可以这样：`git push [主机名] :[远程分支名] :[远程分支名] :[远程分支名]` 。此命令的原理是将空分支推送到远程分支，结果自然就是远程分支被删除。另一个删除远程分支的命令：`git push [主机名] --delete [远程分支名]`。删除远程分支的命令可以在任意本地分支中执行。

## 本地分支的更名与删除

回到实验环境，使用 `git branch -D [分支名]` 删除本地分支，同样地，此命令也可以一次删除多个，将需要删除的分支名罗列在命令后面即可。在此之前，先介绍一个极少用到的命令：给本地分支改名 `git branch -m [原分支名] [新分支名]` ，若修改当前所在分支的名字，原分支名可以省略不写：

好，现在要一次性删除本地分支 ved 和 dev1。需要注意的一点：当前所在的分支不能被删除。切换到 master 分支，然后执行 `git branch -D ved dev1` 命令：

![1558595194002](assets/1558595194002.png)

执行 `git branch -avv` 查看当前仓库分支状态。

# Git tag 和 GitHub releases

## Git 标签的作用

在一个项目中，我们可能需要阶段性地发布一个版本，比如 `V1.0`、`V1.0.2`、`V3.2 Beta` 之类的，Git 的标签可以满足这个需求。在一个长期大型项目中，可能会有数千个提交版本，我们可能需要对重要的节点性提交打个记号，这时也可以使用 Git 的标签功能。在一些项目相关的书籍中，我们会看到 “执行 xxx 命令签出这个版本以查看对应的代码” ，这也是使用 Git 的标签功能做到的。  

## 创建标签

创建标签是给具体的某次提交创建的，跟分支无关。创建标签使用 `git tag [标签名] -m [备注信息] [提交版本号]` 这个命令。其中 `-m [备注信息]` 可以省略不写，但建议不要省略。`[提交版本号]` 可以省略，如果是给当前分支最新的提交创建标签的话。

给当前分支当前版本创建一个标签：

```shell
git tag v1.0 -m '发布项目正式版本 1.0'
```

## 查看标签

执行 `git tag` 命令显示仓库中的全部标签列表，执行 `git show [标签名]` 查看标签详情：

## 删除本地标签

当我们执行 `git add [标签名]` 创建本地标签后，在仓库主目录的 `.git/refs/tags` 目录下就会生成一个标签文件。

执行 `git tag -d [标签名]` 删除本地标签，标签文件也会被删除：

```shell
git tag -d '标签名'
```

## 将本地标签推送到远程仓库

执行 `git push origin [标签名]` 推送标签到远程仓库。

可以使用 `git push origin --tags` 命令将全部本地标签推送至远程仓库。

## 删除远程仓库标签

如果标签废弃不用或者写错了，可以使用 `git push origin :refs/tags/[标签名]` 删除远程仓库的标签，命令中的标签名其实也就是文件名。

```shell
git push origin :refs/tags/[标签名]
```

注意本地标签需要额外删除。

## 签出版本

“如果你从 GitHub 上克隆了这个程序的仓库，那么可以在仓库主目录下执行 git checkout xxx 签出程序的这个版本。” 其实签出版本就是指定某个提交版本创建一个新的分支。

假定当前的 work 仓库就是一个程序，我们要签出 001 版本，执行以下步骤即可。

首先执行 `git checkout [标签名]` 切换到之前的某个提交版本，然后执行 `git checkout -b [新的分支名]` 将此提交版本固定到一个新分支上并切换到此分支：

## GitHub 的 releases

GitHub 的 releases 是 2013 年发布的新功能，旨在协助软件开发者分发新版本给用户。

当项目组织宣布发布一个软件产品的版本，发布过程就是一个将软件交付给最终用户的工作流。版本是具有修改日志和二进制文件的一类对象，它们提供了 Git 工作流之外的完整项目历史，它们也可以从存储库的主页上被访问。发布版 release 附带发布说明和下载软件或源代码的链接。按照许多 Git 项目的约定，发布版本与 Git 的标签 tag 绑定。您可以使用现有的标签，或者让 release 在发布时创建标签。这就是上面查看 GitHub 仓库中标签信息时出现的场景。

标签是 Git 中的概念，而 releases 则是 Github、码云等源码托管商所提供的更高层的概念。Git 本身是没有 releases 这个概念，只有 tag。两者之间的关系则是，release 基于 tag，为 tag 添加更丰富的信息，一般是编译好的文件。