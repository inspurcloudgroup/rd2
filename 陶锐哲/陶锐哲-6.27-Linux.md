# Linux

## 知识点总结

### Linux进程

****
**概念的简述**

程序：执行逻辑的顺序结构指令

进程：程序在数据集合上的一次执行过程。**系统进行资源分配和调度的独立基本单位**

线程：是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流

进程的特性：  
> 动态性：实质是一次程序执行的过程，有状态变化  
> 并发性：做到一个时间段内，有多个程序在运行中  
> 独立性：独立分配资源，独立接受调度，独立地运行  
> 异步性：以不可预知的速度向前推进  
> 结构性：拥有代码段、数据段、PCB（进程控制块，进程存在的唯一标志）

- 并发：在一个时间段内，宏观来看有多个程序都在活动

- 并行：在每一个瞬间，都有多个程序都在同时执行（必须有多个CPU）

简而言之,一个程序至少有一个进程,一个进程至少有一个线程。即程序->进程->线程

****
**进程分类**

- 以进程的功能与服务的对象来分

用户进程：通过执行用户程序、应用程序或称之为内核之外的系统程序而产生的进程，此类进程可以在用户的控制下运行或关闭。

系统进行：通过执行系统内核程序而产生的进程，比如可以执行内存资源分配和进程切换等相对底层的工作；而且该进程的运行不受用户的干预，即使是 root 用户也不能干预系统进程的运行。

- 以应用程序的服务类型来分

交互进程：由一个 shell 终端启动的进程，在执行过程中，需要与用户进行交互操作，可以运行于前台，也可以运行在后台。

批处理进程：该进程是一个进程集合，负责按顺序启动其他的进程。

守护进程：守护进程是一直运行的一种进程，在 Linux 系统启动时启动，在系统关闭时终止。它们独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件。例如 httpd 进程，一直处于运行状态，等待用户的访问。还有经常用的 cron（在 centOS 系列为 crond）进程，这个进程为 crontab 的守护进程，可以周期性的执行用户设定的某些任务。

****
**进程的衍生**

进程们之间有相关性，那么如何产生关联性呢？

启动终端(bash进程)->bash（启动另一个bash进程），这里称呼第一个 bash 进程是第二 bash 进程的父进程，第二 bash 进程是第一个 bash 进程的子进程

这里给出两个系统调用命令：

> fork：是一个系统调用（system call），它的主要作用就是为当前的进程创建一个新的进程，这个新的进程就是它的子进程，这个子进程除了父进程的返回值和 PID 以外其他的都一模一样，如进程的执行代码段，内存信息，文件描述，寄存器状态等等

> exec：系统调用，作用是切换子进程中的执行程序也就是替换其从父进程复制过来的代码段与数据段

这里简单理解一下，有一个父进程，fork之后除了PID不一样，其他信息都直接复制过来。但是如果要改变子程序的代码段和数据段，则用exec系统调用命令。

```
pid_t p;

p = fork();
if (p == (pid_t) -1)
        /* ERROR */
else if (p == 0)
        /* CHILD */
else
        /* PARENT */
```

子进程的退出与资源的回收定然与父进程有很大的相关性。当一个子进程要正常的终止运行时，或者该进程结束时它的主函数 main() 会执行 exit(n); 或者 return n，这里的返回值 n 是一个信号，系统会把这个 SIGCHLD 信号传给其父进程，当然若是异常终止也往往是因为这个信号。

僵尸进程（Zombie）指的是子进程代码执行部分已经结束执行，但若是其进程的进程控制块（PCB）仍驻留在内存中，则进程仍存在。

S代表进程的状态，而Z那就代表Zombie

正常情况，父进程收到返回值exit code（SIGCHLD 信号）与 reason for termination ，然后调用 wait(&status) 获取子进程的退出状态，然后子进程退出。如果没有这个流程，那子进程的PCB一直驻留，成为Zombie.

Linux系统中可用的PID有限，因此会导致无法产生新进程。

那有另一种情况，父进程结束，但未收回子进程。子进程叫孤儿进程，成为init进程的子进程。这种情况稍微好点，不会有危害。

这里有一个特殊进程0，内核初始化时创建，首先调用fork创建子进程1，运行/sbin/init可执行文件，此时0闲置为交换进程，进程1再不断fork来创建其他子进程。所以进程0是所有进程的父辈，都得叫爸爸！

```
# 查看进程的结构
pstree

# 查看进程详细信息
ps -afxo user,ppid,pid,gid,command
```

>  pid 就是该进程的一个唯一编号，ppid 就是该进程的父进程的 pid，command 表示的是该进程通过执行什么样的命令或者脚本而产生的

df![图片描述](https://dn-simplecloud.shiyanlou.com/courses/uid1079862-20190628-1561676396538)

****
**进程组**

进程组由PGID来唯一区分。一般为组内第一个成员的PID值，即领导进程。

```
# 查找进程所在组的PGID
getpgrp()
```

与进程组类似，Session唯一存在。针对一个tty建立，Session中的进程都叫job，链接一个control terminal。其中有一个前台进程组，可以结构终端的输入输出终端信号，其他job后台运行。

> 前台（foreground）就是在终端中运行，能与你有交互的

> 后台（background）就是在终端中运行，但是你并不能与其任何的交互，也不会显示其执行的过程

****
**工作管理**

bash(Bourne-Again shell)支持工作控制（job control）,而 sh（Bourne shell）并不支持。

```
# 程序后台运行，这时无法CTRL+C终止后台运行
ls &
```
![图片描述](https://dn-simplecloud.shiyanlou.com/courses/uid1079862-20190628-1561677309101)

> 这里[1] 374 分别是该 job 的 job number 与该进程的 PID，而最后一行的 Done 表示该命令已经在后台执行完毕。

同样ctrl + z 使我们的当前工作停止并丢到后台中去

![图片描述](https://dn-simplecloud.shiyanlou.com/courses/uid1079862-20190628-1561677456660)

```
# 查看后台的工作
jobs
```

![图片描述](https://dn-simplecloud.shiyanlou.com/courses/uid1079862-20190628-1561677603355)

> 其中第一列显示的为被放置后台 job 的编号，而第二列的 ＋ 表示最近(刚刚、最后)被放置后台的 job，同时也表示预设的工作，也就是若是有什么针对后台 job 的操作，首先对预设的 job，- 表示倒数第二（也就是在预设之前的一个）被放置后台的工作，倒数第三个（再之前的）以后都不会有这样的符号修饰，第三列表示它们的状态，而最后一列表示该进程执行的命令

因此，后台命令也可以前台执行，前台命令也可以后台执行：

```
#后面不加参数提取预设工作，加参数提取指定工作的编号
#ubuntu 在 zsh 中需要 %，在 bash 中不需要 %
fg [%jobnumber]

#与fg类似，加参则指定，不加参则取预设
bg [%jobnumber]

#kill的使用格式如下
kill -signal %jobnumber

#signal从1-64个信号值可以选择，可以这样查看
kill －l
```

|信号值|	作用|
|--|--|
|-1|	重新读取参数运行，类似与restart|
|-2|	如同 ctrl+c 的操作退出|
|-9|	强制终止该任务|
|-15|	正常的方式终止该任务|


****



# 今日体会

- 这里提到早先fork比较耗资源，但是用vfork就好多了，为什么？  
拓展个知识：[fork与vfork](https://blog.csdn.net/jianchi88/article/details/6985326)那这里就给出原因了，fork是直接copy，而vfork是共享数据段。


- 有点懵，job和进程的区别是啥？  
简单理解，就是job是写下的一个命令，命令执行需要进程组来执行，注意是进程组，里面有很多进程的。[process与job](https://www.cnblogs.com/kevin7234/p/10316837.html)


