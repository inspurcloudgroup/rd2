# Java多线程
 
线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。多线程是多任务的一种特别的形式，但多线程使用了更小的资源开销。多线程能满足程序员编写高效率的程序来达到充分利用 CPU 的目的。  
> 线程：程序执行流的最小单元。它是进程内一个相对独立的、可调度的执行单元，是系统独立调度和分派 CPU 的基本单位。
![线程生命周期](https://dn-simplecloud.shiyanlou.com/courses/uid1079862-20190606-1559827678315)

> 多线程：从软件或者硬件上实现多个线程并发执行的技术。在单个程序中同时运行多个线程完成不同的工作。

## 知识点总结

### 多线程的实现
- Thread类，创建和操作线程

- 创建线程：
> 继承Thread类并重写run方法，利用子类创建对象并调用start方法  
> 定义类并实现Runnable接口，实现run()方法。

- 实例

```
public class CreateThread {
	public static void main(String[] args) {
		Thread1 t1 = new Thread1();

		Thread t2 = new Thread(new Thread2());

		t1.start();
		t2.start();
	}

	static class Thread1 extends Thread{
		@Override
		public void run() {
			//重写run方法
			for (int i = 0; i < 100; ++i) {
				System.out.println("Hello! This is " + i);
			}
		}
	}

	static class Thread2 implements Runnable{
		//通过Runnalbe接口来构造
		@Override
		public void run() {
			for (int i = 0; i < 100; ++i) {
				System.out.println("Thanks. There is " +  i);
			}
		}

	}
}

```


### 线程变量
> ThreadLocal，即线程变量，是一个以 ThreadLocal 对象为键、任意对象为值的存储结构。这个结构被附带在线程上，也就是说一个线程可以根据一个 ThreadLocal 对象查询到绑定在这个线程上的一个值  
> 可以通过 set(T)方法来设置一个值，在当前线程下再通过 get()方法获取到原先设置的值。

```
package ThreadLocalDemo;

public class ThreadLocalDemo{

    public static void main(String[] args){
        ThreadDemo threadDemo = new ThreadDemo();
        new Thread(threadDemo).start();
        new Thread(threadDemo).start();
    }
}

class ThreadDemo implements Runnable{
    //使用ThreadLocal的静态方法创建线程变量，并初始化
    private static ThreadLocal<Integer> threadlocal = ThreadLocal.withInitial(() -> 0);

    @Override
    public void run(){
        for (int i = 0; i< 10; i++){
            //get方法获取线程变量值
            Integer integer = threadlocal.get();
            integer += 1;
            //set方法设置线程变量值
            threadlocal.set(integer);
            System.out.println(integer);
        }
    }
}
```

- 如果去掉ThreadLocal，如下代码。则此时两个线程共享变量Integer **线程共享变量**

```
    public void run() {
        for (int i = 0; i < 10; i++) {
            integer++;
            System.out.println(integer);
        }
    }
```

> 注意线程共享变量这种情况，导致线程不安全

### 线程同步（线程锁）
- 多个线程同时操作，出现线程安全问题。**线程同步Synchronized保证同一时刻一个对象只对应一个线程**

- 关键字Synchronized，修饰方法或以同步块的形式进行适用。确保多个线程异步调用方法和同步块
> 对普通方式使用，将会锁住当前实例对象
> 对静态方法使用，将会锁住当前类的 Class 对象
> 对代码块使用，将会锁住代码块中的对象

```
public class SynchronizedDemo{
    private static Object lock = new Object();

    public static void main(String[] args){
        //同步代码块
        synchronized(lock){
            ；
        }
    }

    //静态同步方法
    public synchronized static void staticMethod(){
        ;
    }

    //普通同步方法
    public synchronized void memberMethod(){
        ;
    }
}
```
> java.util.concurrent是 java5 开始引入的并发类库，提供了多种在并发编程中的适用工具类。包括原子操作类，线程池，阻塞队列，Fork/Join 框架，并发集合，线程同步锁等。

### Lock与Unlock
- ReentrantLock比synchronized加锁更加灵活

```
import java.util.concurrent.locks.ReentrantLock;

public class LockDemo{
    private static ReentrantLock lock = new ReentrantLock();

    public static void main(String[] args){
        Thread thread1 = new Thread(() ->{
            lock.lock();
            try{
                //需要同步的代码块
                System.out.println("线程1加锁！");
            }
            finally{
                //在这里一定要解锁，否则造成死锁
                lock.unlock();
                System.out.println("线程1解锁！");
            }
        }
        );
        thread1.start();

        Thread thread2 = new Thread(() -> {
            lock.lock();
            try{
                System.out.println("线程2加锁!");
            }
            finally{
                lock.unlock();
                System.out.println("线程2解锁!");
            }

        }
        );
        thread2.start();
    }

}
```

### 死锁
- 死锁造成系统瘫痪。比如两个线程互相等待对方释放锁

```
public class DeadLockDemo{
    private static Object lockA = new Object();
    private static Object lockB = new Object();

    public static void main(String[] args){
        //使用lambda表达式创建进程

        //线程1
        new Thread(() ->{
            synchronized (lockA){
                try{
                    //线程休眠一段时间，确保另外一个线程获取b锁
                    Thread.sleep(1000);
                }
                catch(InterruptedException e){
                    e.printStackTrace();
                }
                System.out.println("D");
                synchronized(lockB){
                }
            }
        }
        ).start();

        //线程2
        new Thread(() ->{
            synchronized(lockB){
                System.out.println("死锁...");
                synchronized(lockA){

                }
            }
        }
        ).start();
        
    }
}
```
> 上面的编程实例中，线程 1 获取了 lockA 的锁后再去获取 lockB 的锁，而此时 lockB 已经被线程 2 获取，同时线程 2 也想获取 lockA，两个线程进这样僵持了下去，谁也不让，造成了死锁。在编程时，应该避免死锁的出现。

- **饥饿**
指一个可运行的进程尽管能继续执行，但被调度器无限期地忽视，而不能被调度执行的情况。比如当前线程处于一个低优先级的情况下，操作系统每次都调用高优先级的线程运行，就会导致当前线程虽然可以运行，但是一直不能被运行的情况。

# 今日总结与体会
*多线程操作中，加锁解锁不可缺少，但是注意死锁的问题*

*两种加锁方式synchronized和ReentrantLock，注意使用方式*

# 明日计划与安排
明天端午节，计划完成java数据库部分-JDBC。






