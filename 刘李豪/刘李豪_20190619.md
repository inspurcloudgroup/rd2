# 学习内容_201906019


---

## Go语言介绍

### Go 语言的特性
1. 并发编程
Go 语言引入了goroutine，它是 Go 实现快速高效的并发编程的关键。通过调用 go 关键字，我们就可以让函数以 goroutine 的方式进行运行，也就是以协程为单位进行运行。协程比线程更加的轻量级，也更节省系统资源，这使得我们可以创建大量的 goroutine，从而进行轻松且高质量的并发编程。同时，goroutine 内部采用管道channel进行消息传递，从而实现共享内存。
2. 错误处理
Go 语言中的错误处理的哲学和 C 语言一样，函数通过返回错误类型(error)或者bool类型(不需要区分多种错误状态时)表明函数的执行结果，调用检查返回的错误类型值是否是nil来判断调用结果。并引入了 defer 关键字用于标准的错误处理流程，并提供了内置函数panic、recover完成异常的抛出与捕捉。
3. 垃圾回收
Go 语言自带垃圾自动回收的功能，让 Go 语言不需要delete关键字，也不需要free()来释放内存。因此开发者无需考虑何时需要释放之前分配的内存的问题，系统会自动帮我们判断，并在适当的时候进行垃圾处理。垃圾自动回收是 Go 语言的一个特点，也是一大亮点。
4. 多返回值
Go 语言和 Python 一样也支持函数的多返回值功能，这个特性让开发者可以从原来用各种比较别扭的方式返回多个值得痛苦中解脱出来，不需要为了一次返回多个值而专门定义一个结构体。并且每个返回值都有自己的名字，开发者还可以选择具体需要返回的值，只需要使用下划线作为占位符来丢掉不要的返回值即可。
5. 匿名函数
Go 语言支持常规的匿名函数和闭包，开发者可以随意对匿名函数变量进行传递和调用，下面就是一个匿名函数样例
```
f := func(x,y int) int {
    return x+y
}
```

### Go 语言可以做什么
专门针对多处理器系统应用程序的编程进行了优化，使用 Go 编译的程序可以媲美 C 或 C++代码的速度，而且更加安全、支持并行进程。Go 的目标是希望提升现有编程语言对程序库等依赖性(dependency)的管理，这些软件元素会被应用程序反复调用。由于存在并行编程模式，因此也被设计用来解决多处理器的任务。目前，已经有很多公司开始使用 Go 语言开发自己的服务，甚至完全转向 Go 开发，也诞生了很多基于 Go 的服务和应用，比如Dokcer、k8s等。

### 第一个 Go 程序
使用VIM编辑源代码：
```
$ vim hello.go
```
输入代码：
```
package main

import (
    "fmt" //导入fmt包，调用其中的Println()函数
)

func main() {
    fmt.Println("Hello，world！")
}
```
![image](https://user-images.githubusercontent.com/50911356/59773583-6b2dbd00-92e0-11e9-99b4-c8b7def85678.png)
运行：
```
go run hello.go
```
![image](https://user-images.githubusercontent.com/50911356/59775200-59014e00-92e3-11e9-9d76-e47432c21312.png)

## Go 语言基础

### 常量
常量使用关键字const声明，下面有几个例子：
```
const limit = 512           
const top uint16 = 1421     
const Pi float64 = 3.1415926
const x,y int = 1,3 //多重赋值
```
Go 的常量定义可以限定常量类型，但不是必需的。如果定义常量时没有指定类型，那么该常量就是无类型常量，也叫字面常量。

当需要设置多个常量的时候，不必重复使用const关键字，可以使用以下语法:
```
const (
    Cyan = 0
    Black = 1
    White = 2
)
```

Go 语言还预定义了这些常量：true、false、iota。 iota是一个可以被编译器修改的常量，在const关键字出现时被重置为 0，在下一个 const 出现之前，每出现一次 iota,其所代表的数字自动加 1。下面通过一个例子讲解 iota 的用法：
```
const (
    a = iota  //a == 0
    b = iota  //b ==1
    c = iota  //c == 2
)

const d = iota //d==0,因为const的出现，iota被重置为0
```

### 变量
Go 语言引入了关键字var对变量进行声明，也可以使用:=来对变量直接进行初始化，Go 编译器会自动推导出该变量的类型，这大大的方便了开发者的工作。但是需要注意的是:=左侧的变量不能是已经被声明过的，否则会导致编译器错误。以下是 Go 声明和初始化变量的各种方法：
```
var a int
var b string
var c float64
var d [5] int  //数组
var e [] int   //数组切片
var f * int    //正确
var v1 int = 5 //正确
var v2 = 5     //正确，编译器自动推导出V2类型
v3 := 5        //正确，编译器自动推导出V3的类型
```

#### 多重赋值
Go 语言提供了大多数语言不支持的多重赋值，这使得变量的交换变得十分简单。下面通过一个例子来了解 Go 语言的多重赋值：
```
i := 2
j := 3
i, j = j, i  //交换i和j的值，此时i == 3，j == 2
```
这样的方式可以一行代码实现变量的交换，明显的减少代码的行数，而不需要像 C/C++那样引入一个中间变量

### 数据类型

####整型
Go 语言提供了 11 种整型，如下列表所示:
```
byte	等同于 uint8
int	依赖于不同平台下的实现，可以是 int32 或者 int64
int8	[-128, 127]
int16	[-32768, 32767]
int32	[-2147483648, 2147483647]
int64	[-9223372036854775808, 9223372036854775807]
rune	等同于 int32
uint	依赖于不同平台下的实现，可以是 uint32 或者 uint64
uint8	[0, 255]
uint16	[0, 65535]
uint32	[0, 4294967295]
uint64	[0, 18446744073709551615]
uintptr	一个可以恰好容纳指针值的无符号整型（对 32 位平台是 uint32, 对 64 位平台是 uint64）
```

在C语言中我们可以通过sizeof操作符查看类型的字节长度，在 Go 语言中可以通过unsafe.Sizeof函数进行，使用vim创建源文件type_length.go:
```
package main

import (
    "fmt"
    "unsafe"
)

func main() {
    a := 12
    fmt.Println("length of a: ", unsafe.Sizeof(a))
    var b int = 12
    fmt.Println("length of b(int): ", unsafe.Sizeof(b))
    var c int8 = 12
    fmt.Println("length of c(int8): ", unsafe.Sizeof(c))
    var d int16 = 12
    fmt.Println("length of d(int16): ", unsafe.Sizeof(d))
    var e int32 = 12
    fmt.Println("length of e(int32): ", unsafe.Sizeof(e))
    var f int64 = 12
    fmt.Println("length of f(int64): ", unsafe.Sizeof(f))
}
```
![image](https://user-images.githubusercontent.com/50911356/59776356-3e2fd900-92e5-11e9-86c9-90c4c546e2ae.png)
运行结果：
![image](https://user-images.githubusercontent.com/50911356/59776427-5d2e6b00-92e5-11e9-9ee6-43137999e2d7.png)

#### 浮点型
Go 语言提供了两种浮点类型和两种复数类型, 具体如下：
```
float32	±3.402 823 466 385 288 598 117 041 834 845 169 254 40x1038 计算精度大概是小数点后 7 个十进制数
float64	±1.797 693 134 862 315 708 145 274 237 317 043 567 981x1038 计算精度大概是小数点后 15 个十进制数
complex32	复数，实部和虚部都是 float32
complex64	复数，实部和虚部都是 float64
```
布尔类型
Go 语言提供了内置的布尔值true和false。Go 语言支持标准的逻辑和比较操作，这些操作的结果都是布尔值。值得注意的地方是可以通过!b的方式反转变量b的真假。需要注意的是布尔类型不能接受其他类型的赋值，不支持自动或强制的类型转换。实例代码如下：
```
var a bool
a = true
b := (2 == 3) //b也会被推导为bool类型

//错误示范
var b bool
b = 1 //编译错误
b = bool(1) //编译错误
```

#### 字符串
Go 语言中字符串的可以使用双引号( " )或者反引号( ` )来创建。双引号用来创建可解析的字符串字面量，所谓可解析的是指字符串中的一些符号可以被格式化为其他内容，如\n在在输出时候会被格式化成换行符， 如果需要按照原始字符输出必须进行转义。而反引号创建的字符串原始是什么样，那输出还是什么，不需要进行任何转义。以下是几个例子:
```
t1 := "\"hello\""             //内容： "hello"
t2 := `"hello"`               //内容：和t1一致
t3 := "\u6B22\u8FCE"          //内容：欢迎
```
Go 语言中的部分转义字符如下表所示：
```
\\	表示反斜线
'	单引号
"	双引号
\n	换行符
\uhhhh	4 个 16 进制数字给定的 Unicode 字符
```
在 Go 语言中单个字符可以使用单引号( ' )来创建。之前的课程中，我们有学习过rune类型，它等同于int32，在 Go 语言中，一个单一的字符可以用一个单一的rune来表示。这也是容易理解的，因为 Go 语言的字符串是 UTF-8 编码，其底层使用 4 个字节表示，也就是 32 bit。

在 Go 语言中，字符串支持切片操作，但是需要注意的是如果字符串都是由 ASCII 字符组成，那可以随便使用切片进行操作，但是如果字符串中包含其他非 ASCII 字符，直接使用切片获取想要的单个字符时需要十分小心，因为对字符串直接使用切片时是通过字节进行索引的，但是非 ASCII 字符在内存中可能不是由一个字节组成。如果想对字符串中字符依次访问，可以使用range操作符。另外获取字符串的长度可能有两种含义，一种是指获取字符串的字节长度，一种是指获取字符串的字符数量。字符串支持以下操作：
```
s += t	将字符串 t 追加到 s 末尾
s + t	将字符串 s 和 t 级联
s[n]	从字符串 s 中索引位置为 n 处的原始字节
s[n:m]	从位置 n 到位置 m-1 处取得的字符（字节）串
s[n:]	从位置 n 到位置 len(s)-1 处取得的字符（字节）串
s[:m]	从位置 0 到位置 m-1 处取得的字符（字节）串
len(s)	字符串 s 中的字节数
len([]rune(s))	字符串 s 中字符的个数，可以使用更快的方法 utf8.RuneCountInString()
[ ]rune(s)	将字符串 s 转换为一个 unicode 值组成的串
string(chars)	chars 类型是[]rune 或者[]int32, 将之转换为字符串
[ ]byte(s)	无副本的将字符串 s 转换为一个原始的字节的切片数组，不保证转换的字节是合法的 UTF-8 编码字节
```
