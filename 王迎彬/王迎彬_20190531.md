#Linux 学习心得（12）

#一、Linux进程之初步了解

进程与程序、进程的衍生、工作管理。

##1.概念

概念的理解

首先程序与进程是什么？程序与进程又有什么区别？

程序（procedure）：不太精确地说，程序就是执行一系列有逻辑、有顺序结构的指令，帮我们达成某个结果。就如我们去餐馆，给服务员说我要牛肉盖浇饭，她执行了做牛肉盖浇饭这么一个程序，最后我们得到了这么一盘牛肉盖浇饭。它需要去执行，不然它就像一本武功秘籍，放在那里等人翻看。

进程（process）：进程是程序在一个数据集合上的一次执行过程，在早期的UNIX、Linux 2.4及更早的版本中，它是系统进行资源分配和调度的独立基本单位。同上一个例子，就如我们去了餐馆，给服务员说我要牛肉盖浇饭，她执行了做牛肉盖浇饭这么一个程序，而里面做饭的是一个进程，做牛肉汤汁的是一个进程，把牛肉汤汁与饭混合在一起的是一个进程，把饭端上桌的是一个进程。它就像是我们在看武功秘籍这么一个过程，然后一个篇章一个篇章地去练。

简单来说，程序是为了完成某种任务而设计的软件，比如 vim 是程序。什么是进程呢？进程就是运行中的程序。

程序只是一些列指令的集合，是一个静止的实体，而进程不同，进程有以下的特性：

动态性：进程的实质是一次程序执行的过程，有创建、撤销等状态的变化。而程序是一个静态的实体。

并发性：进程可以做到在一个时间段内，有多个程序在运行中。程序只是静态的实体，所以不存在并发性。

独立性：进程可以独立分配资源，独立接受调度，独立地运行。

异步性：进程以不可预知的速度向前推进。

结构性：进程拥有代码段、数据段、PCB（进程控制块，进程存在的唯一标志）。也正是因为有结构性，进程才可以做到独立地运行。

并发：在一个时间段内，宏观来看有多个程序都在活动，有条不紊的执行（每一瞬间只有一个在执行，只是在一段时间有多个程序都执行过）

并行：在每一个瞬间，都有多个程序都在同时执行，这个必须有多个 CPU 才行

引入进程是因为传统意义上的程序已经不足以描述 OS 中各种活动之间的动态性、并发性、独立性还有相互制约性。程序就像一个公司，只是一些证书，文件的堆积（静态实体）。而当公司运作起来就有各个部门的区分，财务部，技术部，销售部等等，就像各个进程，各个部门之间可以独立运做，也可以有交互（独立性、并发性）。

而随着程序的发展越做越大，又会继续细分，从而引入了线程的概念，当代多数操作系统、Linux 2.6及更新的版本中，进程本身不是基本运行单位，而是线程的容器。就像上述所说的，每个部门又会细分为各个工作小组（线程），而工作小组需要的资源需要向上级（进程）申请。

线程（thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。因为线程中几乎不包含系统资源，所以执行更快、更有效率。

简而言之,一个程序至少有一个进程,一个进程至少有一个线程。线程的划分尺度小于进程，使得多线程程序的并发性高。另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。就如下图所示：
![](https://i.imgur.com/FC7870B.png)
##2.工作管理
bash(Bourne-Again shell)支持工作控制（job control）,而 sh（Bourne shell）并不支持。并且每个终端或者说 bash 只能管理当前终端中的 job，不能管理其他终端中的 job。比如我当前存在两个 bash 分别为 bash1、bash2，bash1 只能管理其自己里面的 job 并不能管理 bash2 里面的 job。

我们都知道当一个进程在前台运作时我们可以用 ctrl + c 来终止它，但是若是在后台的话就不行了。

我们可以通过 & 这个符号，让我们的命令在后台中运行：ls &
![](https://i.imgur.com/lgwEQ4R.png)

图中所显示的 [1] 236分别是该 job 的 job number 与该进程的 PID，而最后一行的 Done 表示该命令已经在后台执行完毕
。
我们还可以通过 ctrl + z 使我们的当前工作停止并丢到后台中去
被停止并放置在后台的工作我们可以使用这个命令来查看：jobs
其中第一列显示的为被放置后台 job 的编号，而第二列的 ＋ 表示最近(刚刚、最后)被放置后台的 job，同时也表示预设的工作，也就是若是有什么针对后台 job 的操作，首先对预设的 job，- 表示倒数第二（也就是在预设之前的一个）被放置后台的工作，倒数第三个（再之前的）以后都不会有这样的符号修饰，第三列表示它们的状态，而最后一列表示该进程执行的命令

我们可以通过这样的一个命令将后台的工作拿到前台来：

后面不加参数提取预设工作，加参数提取指定工作的编号

ubuntu 在 zsh 中需要 %，在 bash 中不需要 %
fg [%jobnumber]
之前我们通过 ctrl + z 使得工作停止放置在后台，若是我们想让其在后台运作我们就使用这样一个命令：

与fg类似，加参则指定，不加参则取预设
bg [%jobnumber]

既然有方法将被放置在后台的工作提至前台或者让它从停止变成继续运行在后台，当然也有方法删除一个工作，或者重启等等

kill的使用格式如下：
kill -signal %jobnumber

signal从1-64个信号值可以选择，可以这样查看
kill －l

其中常用的有这些信号值：

-1	重新读取参数运行，类似与restart

-2	如同 ctrl+c 的操作退出

-9	强制终止该任务

-15	正常的方式终止该任务

注意

若是在使用kill＋信号值然后直接加 pid，你将会对 pid 对应的进程进行操作

若是在使用kill+信号值然后 ％jobnumber，这时所操作的对象是 job，这个数字就是就当前 bash 中后台的运行的 job 的 ID
![](https://i.imgur.com/E46Iniv.png)
#二、Linux进程之管理控制

通过本实验我们将掌握一些 Linux 所提供的工具来进行进程的查看与控制，掌握这些工具让我们能在某些进程出现异常的时候及时查看相关的指标，从而解决问题。

不管在测试的时候、在实际的生产环境中，还是自己的使用过程中，难免会遇到一些进程异常的情况，所以 Linux 为我们提供了一些工具来查看进程的状态信息。我们可以通过 top 实时的查看进程的状态，以及系统的一些信息（如 CPU、内存信息等），我们还可以通过 ps 来静态查看当前的进程信息，同时我们还可以使用 pstree 来查看当前活跃进程的树形结构。

学习内容：查看进程的运行状态、进程的结束控制、进程的执行顺序

1 .top 工具的使用

top 工具是我们常用的一个查看工具，能实时的查看我们系统的一些关键信息的变化:top

top 是一个在前台执行的程序，所以执行后便进入到这样的一个交互界面，正是因为交互界面我们才可以实时的获取到系统与进程的信息。在交互界面中我们可以通过一些指令来操作和筛选。在此之前我们先来了解显示了哪些信息。

我们看到 top 显示的第一排，内容解释：

top	表示当前程序的名称

11:05:18	表示当前的系统的时间

up 8 days,17:12	表示该机器已经启动了多长时间

1 user	表示当前系统中只有一个用户

load average: 0.29,0.20,0.25	

分别对应1、5、15分钟内cpu的平均负载

第二行是进程的一个情况统计：

Tasks: 26 total	进程总数

1 running	1个正在运行的进程数

25 sleeping	25个睡眠的进程数

0 stopped	没有停止的进程数

0 zombie	没有僵尸进程数

第三行数据，这一行基本上是 CPU 的一个使用情况的统计了：

Cpu(s): 1.0%us	用户空间进程占用CPU百分比

1.0% sy	内核空间运行占用CPU百分比

0.0%ni	用户进程空间内改变过优先级的进程占用CPU百分比

97.9%id	空闲CPU百分比

0.0%wa	等待输入输出的CPU时间百分比

0.1%hi	硬中断(Hardware IRQ)占用CPU的百分比

0.0%si	软中断(Software IRQ)占用CPU的百分比

0.0%st	(Steal time) 是 hypervisor 等虚拟服务中，虚拟 CPU 等待实际 CPU 的时间的百分比

CPU 利用率是对一个时间段内 CPU 使用状况的统计，通过这个指标可以看出在某一个时间段内 CPU 被占用的情况，而 Load Average 是 CPU 的 Load，它所包含的信息不是 CPU 的使用率状况，而是在一段时间内 CPU 正在处理以及等待 CPU 处理的进程数情况统计信息，这两个指标并不一样。

第四行数据基本上是内存的一个使用情况的统计：

8176740 total	物理内存总量

8032104 used	使用的物理内存总量

144636 free	空闲内存总量

313088 buffers	用作内核缓存的内存量

注意：系统中可用的物理内存最大值并不是 free 这个单一的值，而是 free + buffers + swap 中的 cached 的和。

第五行数据，基本上是交换区的一个使用情况的统计：

total	交换区总量

used	使用的交换区总量

free	空闲交换区总量

cached	缓冲的交换区总量,内存中的内容被换出到交换区，而后又被换入到内存，但使用过的交换区尚未被覆盖

再下面就是进程的一个情况了
PID	进程id

USER	该进程的所属用户

PR	该进程执行的优先级 priority 值

NI	该进程的 nice 值

VIRT	该进程任务所使用的虚拟内存的总数

RES	该进程所使用的物理内存数，也称之为驻留内存数

SHR	该进程共享内存的大小

S	该进程进程的状态: S=sleep R=running Z=zombie

%CPU	该进程CPU的利用率

%MEM	该进程内存的利用率

TIME+	该进程活跃的总时间

COMMAND	该进程运行的名字

在上文我们曾经说过 top 是一个前台程序，所以是一个可以交互的：

q	退出程序

I	切换显示平均负载和启动时间的信息

P	根据CPU使用百分比大小进行排序

M	根据驻留内存大小进行排序

i	忽略闲置和僵死的进程，这是一个开关式命令

k	终止一个进程，系统提示输入 PID 及发送的信号值。一般终止进程用 15 信号，不能正常结束则使用 9 信号。安全模式下该命令被屏蔽。

好好的利用 top 能够很有效的帮助我们观察到系统的瓶颈所在，或者是系统的问题所在。
![](https://i.imgur.com/Taix9lO.png)

##2. ps 工具的使用

ps 也是我们最常用的查看进程的工具之一，我们通过这样的一个命令来了解一下，他能给我带来哪些信息：ps aux/ps axjf

所显示的内容解释：

F	进程的标志（process flags），当 flags 值为 1 则表示此子程序只是 fork 但没有执行 exec，为 4 表示此程序使用超级管理员 root 权限

USER	进程的拥有用户

PID	进程的 ID

PPID	其父进程的 PID

SID	session 的 ID

TPGID	前台进程组的 ID

%CPU	进程占用的 CPU 百分比

%MEM	占用内存的百分比

NI	进程的 NICE 值

VSZ	进程使用虚拟内存大小

RSS	驻留内存中页的大小

TTY	终端 ID

S or STAT	进程状态

WCHAN	正在等待的进程资源

START	启动进程的时间

TIME	进程消耗CPU的时间

COMMAND	命令的名称和参数

TPGID栏写着-1的都是没有控制终端的进程，也就是守护进程
STAT表示进程的状态，而进程的状态有很多，如下表所示

状态	解释
R	Running.运行中

S	Interruptible Sleep.等待调用

D	Uninterruptible Sleep.不可中断睡眠

T	Stoped.暂停或者跟踪状态

X	Dead.即将被撤销

Z	Zombie.僵尸进程

W	Paging.内存交换

N	优先级低的进程

<	优先级高的进程

s	进程的领导者

L	锁定状态

l	多线程状态

+	前台进程
+	
其中的 D 是不能被中断睡眠的状态，处在这种状态的进程不接受外来的任何 signal，所以无法使用 kill 命令杀掉处于D状态的进程，无论是 kill，kill -9 还是 kill -15，一般处于这种状态可能是进程 I/O 的时候出问题了。

ps 工具有许多的参数，下面给大家解释部分常用的参数

使用 -l 参数可以显示自己这次登陆的 bash 相关的进程信息罗列出来
ps -l

相对来说我们更加常用下面这个命令，他将会罗列出所有的进程信息：ps aux

若是查找其中的某个进程的话，我们还可以配合着 grep 和正则表达式一起使用：ps aux | grep zsh

此外我们还可以查看时，将连同部分的进程呈树状显示出来：ps axjf
当然如果你觉得使用这样的此时没有把你想要的信息放在一起，我们也可以是用这样的命令，来自定义我们所需要的参数显示：ps -afxo user,ppid,pid,pgid,command
![](https://i.imgur.com/uj7yKhz.png)
##3 .pstree 工具的使用
通过 pstree 可以很直接的看到相同的进程数量，最主要的还是我们可以看到所有进程之间的相关性：pstree

pstree -up
参数选择：
-A  ：各程序树之间以 ASCII 字元來連接；

-p  ：同时列出每个 process 的 PID；

-u  ：同时列出每个 process 的所屬账户名称。

##4.进程的管理
本节将会为大家介绍如何去管理进程的。
(1) kill 命令的掌握
上个实验中我们讲诉了进程之间是如何衍生，之间又有什么相关性，我们来回顾一下，当一个进程结束的时候或者要异常结束的时候，会向其父进程返回一个或者接收一个 SIGHUP 信号而做出的结束进程或者其他的操作，这个 SIGHUP 信号不仅可以由系统发送，我们可以使用 kill 来发送这个信号来操作进程的结束或者重启等等。
上节课程我们使用 kill 命令来管理我们的一些 job，这节课我们将尝试用 kill 来操作下一些不属于 job 范畴的进程，直接对 pid 下手
首先我们使用图形界面打开了 gedit、gvim，用 ps 可以查看到
ps aux
使用9这个信号强制结束 gedit 进程
kill -9 1608
我们再查找这个进程的时候就找不到了
ps aux | grep gedit 
![](https://i.imgur.com/ezIfg7h.png)
(2)进程的执行顺序

我们在使用 ps 命令的时候可以看到大部分的进程都是处于休眠的状态，如果这些进程都被唤醒，那么该谁最先享受 CPU 的服务，后面的进程又该是一个什么样的顺序呢？进程调度的队列又该如何去排列呢？

当然就是靠该进程的优先级值来判定进程调度的优先级，而优先级的值就是上文所提到的 PR 与 nice 来控制与体现了

而 nice 的值我们是可以通过 nice 命令来修改的，而需要注意的是 nice 值可以调整的范围是 -20 ~ 19，其中 root 有着至高无上的权力，既可以调整自己的进程也可以调整其他用户的程序，并且是所有的值都可以用，而普通用户只可以调制属于自己的进程，并且其使用的范围只能是 0 ~ 19，因为系统为了避免一般用户抢占系统资源而设置的一个限制

这个实验在环境中无法做，因为权限不够，可以自己在本地尝试

打开一个程序放在后台，或者用图形界面打开

nice -n -5 vim &

用 ps 查看其优先级

ps -afxo user,ppid,pid,stat,pri,ni,time,command | grep vim
我们还可以用 renice 来修改已经存在的进程的优先级，同样因为权限的原因在实验环境中无法尝试：renice -5 pid