#基于LINUX的C++（3）

##一、函数

###1.函数调用

函数调用：主调（客户）函数与被调（服务器）函数

函数调用时的参数与返回值：

例一： Swap( a, b );

例二： n = Add( a, b ); 

###2.函数声明与调用

函数的实现与调用格式说明：作为函数接口一般出现在头文件中。

格式：函数返回值类型函数名称 (形式参数列表 );

例一： int Add( int x, int y );

例二： void Swap( int x, int y );

例三： void Compute(); 

###3.函数定义

函数实现：函数定义，使用编程语言给出函数的执行步骤；

函数返回值：函数完成后带回来的结果主调函数可以使用；

谓词函数：返回 bool类型值的函数，表达某项任务是否完成或某个条件是否满足；

函数重载。

###4.函数调用栈框架

值传递机制

（1）形式参数在函数调用时才分配存储空间，并接受实际参数的值 ；

（2）实际参数可以为复杂的表达式，在函数调用前获得计算 ；

（3）形式参数与实际参数可同名，也可不同名 ；

（4）参数较多时，实际参数值逐一赋值，它们必须保持数目、类型、顺序的一致 ；

（5）值的复制过程是单向不可逆的，函数内部对形式参数值的修改不会反映到实际参数中去 ；

（6）函数参数一般为函数输入集的一部分，函数输出集一般使用返回值表示，只有使用特殊的手段才可以将函数参数作为函数输出集的一部分。

###5.练习1：编写函数IsPrime，判断某个大于2的正整数是否为素数。

    bool IsPrime( unsigned int n )
    {
      unsigned int i = 3, t = (unsigned int)sqrt(n) + 1;
      if( n % 2 == 0 )
        return false;
      while( i <= t )
      {
        if( n % i == 0 )
          return false;
        i += 2;
      }
      return true;
    }
练习2：编写函数gcd与lcm，分别求两个正整数的最大公约数与最小公倍数。
    #include <iostream>
    int add(int a, int b);
    using namespace std;
    bool isPrime(int num);
    int gcd(int a, int b);
    int lcm(int a, int b);

    int main() {
        int a = 20, b = 170, g, lc;
        g = gcd(a, b);
        lc = lcm(a, b);
        cout << "gcd(" << a << "," << b << ") = " << g << endl;
        cout << "lcm(" << a << "," << b << ") = " << lc << endl;
        return 0;
    }
    int lcm(int a, int b) {
        int g = gcd(a, b);
        return a * b / g;
    }

    int gcd(int a, int b) {
        int square = a * b;
        int g = 1;
        if (isPrime(a) || isPrime(b)) {
            g = 1;
        } else {
            for (int i = 1; i <= (a > b ? a : b); ++i) {
                int k = square / (i * i);
                if (k * (i * i) == square) {
                    g = i;
                }
            }
        }
        return g;
    }
    bool isPrime(int num) {
        bool prime = true;
        for (int i = 2; i <= num / 2; ++i) {
            if (num % i == 0) {
                prime = false;
            }
        }
        return prime;
    }
    int add(int a, int b) {
        return a + b;
    }
![](https://i.imgur.com/6yzcybT.jpg)
##二、算法

###1.算法的基本概念与特征

算法基本概念：解决问题的方法与步骤；

设计算法的目的：给出解决问题的逻辑描述，根据算法描述进行实际编程
算法特征：

（1）有穷性：算法在每种情况下都可以在有限步后终止；

（2）确定性：算法步骤的顺序和内容没有二义性；

（3）输入：算法有零个或多个输入；

（4）输出：算法至少具有一个输出；

（5）有效性：所有操作具有明确含义，并能在有限时间内完成；

正确性不是算法的特征，算法的正确性需要数学证明

###2.算法描述

（1）伪代码

混合自然语言与计算机语言、数学语言的算法描述方法

优点：方便，容易表达设计者思想，能够清楚描述算法流程，便于修改
缺点：不美观，复杂算法不容易理解

（2）流程图（程序框图）

使用图形表示算法执行逻辑

优点：美观，算法表达清晰

缺点：绘制复杂，不易修改，占用过多篇幅

###3.算法选择

正确性：算法是否完全正确？

效率：在某些场合，对程序效率的追求具有重要意义

可理解性：算法是否容易理解，也是必须要考虑的

算法评估：衡量算法的好坏，主要是效率

###4.递归算法

递归问题的引入

递推公式：数学上非常常见

例一：阶乘函数：1! = 1，n! = n × (n-1)!

例二：斐波那契数列函数：f(1) = f(2) = 1，f(n) = f(n-1) + f(n-2)

递推函数一定是分段函数，具有初始表达式，递推函数的计算逻辑：逐步简化问题规模。

递归的工作步骤

（1）递推过程：逐步分解问题，使其更简单

（2）回归过程：根据简单情形组装最后的答案

###5.循环与递归的比较

（1）循环使用显式的循环结构重复执行代码段，递归使用重复的函数调用执行代码段；

（2）循环在满足其终止条件时终止执行，而递归则在问题简化到最简单情形时终止执行；

（3）循环的重复是在当前迭代执行结束时进行，递归的重复则是在遇到对同名函数的调用时进行；

（4）循环和递归都可能隐藏程序错误，循环的条件测试可能永远为真，递归可能永远退化不到最简单情形；

（5）理论上，任何递归程序都可以使用循环迭代的方法解决，递归函数的码更短小精悍，一旦掌握递归的思考方法，递归程序更易理解。

###6.递归信任

（1）递归实现是否检查了最简单情形

在尝试将问题分解成子问题前，首先应检查问题是否已足够简单，在大多数情况下，递归函数以 if 开头，如果程序不是这样，仔细检查源程序。

（2）是否解决了最简单情形

大量递归错误是由没有正确解决最简单情形导致的，最简单情形不能调用递归

（3）递归分解是否使问题更简单，只有分解出的子问题更简单，递归才能正确工作，否则将形成无限递归，算法无法终止。

（4）问题简化过程是否能够确实回归最简单情形，还是遗漏了某些情况

如汉诺塔问题需要调用两次递归过程，程序中如果遗漏了任意一个都会导致错误

（5）子问题是否与原始问题完全一致

如果递归过程改变了问题实质，则整个过程肯定会得到错误结果；

（6）使用递归信任时，子问题的解是否正确组装为原始问题的解
将子问题的解正确组装以形成原始问题的解也是必不可少的步骤。

###7.容错

容错的定义：允许错误的发生

错误的处理：

（1）很少见的特殊情况或普通错误，忽略该错误不对程序运行结果产生影响

（2）用户输入错误，通知用户错误性质，提醒用户更正输入

（3）致命错误，通知用户错误的性质，停止执行

典型容错手段：数据有效性检查、程序流程的提前终止。

###9.算法复杂度
引入算法复杂度的目的：度量算法的效率与性能；

大 O 表达式：算法效率与性能的近似表示（定性描述），算法执行时间与问题规模的关系。

表示原则：忽略所有对变化趋势影响较小的项，例如多项式忽略高阶项之外的所有项；忽略所有与问题规模无关的常数，例如多项式的系数。

###10.练习一
设计算法，递归两种策略求二项式系数C(n,k)。其中，n为自然数，k为不大于n的非负整数。

    #include <iostream>
    using namespace std;
    //求阶乘
    template<int N> struct Factorial
    {
        enum 
        {
            value = Factorial<N-1>::value * N
        };
    };

    template<> struct Factorial<0> 
    {
        enum 
        { 
            value = 1
        };
    };
    #define m 10
    #define n 12
    int main()
    {
        cout<<" = " << Factorial<n>::value/(Factorial<m>::value*Factorial<n-m>::value) << endl;
    }


![](https://i.imgur.com/pO1zQlj.png)
















