## 王新雨 0531 当日总结

## 1 学习内容


## 设计模式

### 装饰者模式

装饰者模式（Decorator Pattern，有的也用 Wrapper Pattern）就是动态地把职责附加到已有对象上去，实现功能扩展。这种特性，使得装饰者模式提供了比继承更具有弹性的解决方案。

![图片描述](https://dn-simplecloud.shiyanlou.com/courses/uid1080331-20190603-1559566000240)

![图片描述](https://dn-simplecloud.shiyanlou.com/courses/uid1080331-20190603-1559566006099)

**装饰者模式应用**

当你需要动态地给一个对象添加功能，实现功能扩展的时候，就可以使用装饰者模式。

Java IO 类中有一个经典的装饰者模式应用， BufferedReader 装饰了 InputStreamReader.
```
BufferedReader input = new BufferedReader(new InputStreamReader(System.in));
```

   - InputStreamReader(InputStream in) - InputSteamReader 读取 bytes 字节内容，然后转换成 characters 流 输出。
   - BufferedReader(Reader in) - 从 characters 流 中读取内容并缓存。

**装饰者模式、适配器模式区别**

   - 关于新职责：适配器也可以在转换时增加新的职责，但其主要目的并不在此；而装饰者模式主要目的，就是给被装饰者增加新职责用的。

   - 关于原接口：适配器模式是用新接口来调用原接口，原接口对新系统来说是不可见或者说不可用的；而装饰者模式原封不动的使用原接口，系统对装饰的对象也通过原接口来完成使用。

   - 关于其包裹的对象：适配器是知道被适配者的详细情况的（就是那个类或那个接口）；而装饰者只知道其接口是什么，至于其具体类型（是基类还是其他派生类）只有在运行期间才知道。

### 观察者模式

观察者模式（Observer Pattern）就是一种 “发布者-订阅者” 的模式。有时也被称为 “模型-视图”模式、“源-监听者”模式等。在这种模式中，由一个目标对象来管理所有依赖与它的观察者对象，并且当这个目标对象自身发生改变时，会主动向它的观察者们发出通知。

![图片描述](https://dn-simplecloud.shiyanlou.com/courses/uid1080331-20190603-1559569431528)

![图片描述](https://dn-simplecloud.shiyanlou.com/courses/uid1080331-20190603-1559569518386)

**观察者模式的应用**

观察者模式也可以理解为 “源-监听者” 模式，这种应用就太多了。举个简单的例子就是各种 listener，比如当你有一个按键，你肯定要给这个按键添加监听事件（listener）来完成指定动作吧，这就是一种应用。

### 单例模式
单例模式（Singleton Pattern），顾名思义，就是被单例的对象只能有一个实例存在。单例模式的实现方式是，一个类能返回对象的一个引用（永远是同一个）和一个获得该唯一实例的方法（必须是静态方法）。通过单例模式，我们可以保证系统中只有一个实例，从而在某些特定的场合下达到节约或者控制系统资源的目的。

   - 饿汉模式：一上来就需要给它新建一个实例。但这种方法有一个明显的缺点，那就是不管有没有调用过获得实例的方法（本例中为 getWife() ），每次都会新建一个实例。

![图片描述](https://dn-simplecloud.shiyanlou.com/courses/uid1080331-20190603-1559570242039)

   - 懒汉模式：一开始不新建实例，只有当它需要使用的时候，会先判断实例是否为空，如果为空才会新建一个实例来使用。

![图片描述](https://dn-simplecloud.shiyanlou.com/courses/uid1080331-20190603-1559570450901)

   - 线程安全的懒汉模式：在基本的懒汉模式上，把它设为线程同步（synchronized）就好了。synchronized 的作用就是保证在同一时刻最多只有一个线程运行，这样就避免了多线程带来的问题。

![图片描述](https://dn-simplecloud.shiyanlou.com/courses/uid1080331-20190603-1559570530676)

   - 双重检验锁（double check）：线程安全的懒汉模式解决了多线程的问题，看起来完美了。但是它的效率不高，每次调用获得实例的方法 getWife() 时都要进行同步，但是多数情况下并不需要同步操作（例如我的 wife 实例并不为空可以直接使用的时候，就不需要给 getWife() 加同步方法，直接返回 wife 实例就可以了）。所以只需要在第一次新建实例对象的时候，使用同步方法。

![图片描述](https://dn-simplecloud.shiyanlou.com/courses/uid1080331-20190603-1559570884876)

   - 静态内部类：利用了 JVM 自身的机制来保证线程安全，因为 WifeHolder 类是私有的，除了 getWife() 之外没有其它方式可以访问实例对象，而且只有在调用 getWife() 时才会去真正创建实例对象。（这里类似于 “懒汉模式”）

![图片描述](https://dn-simplecloud.shiyanlou.com/courses/uid1080331-20190603-1559571084288)

   - 枚举: 可以通过 Wife.INSTANCE 来访问实例对象，这比 getWife() 要简单得多，而且创建枚举默认就是线程安全的，还可以防止反序列化带来的问题。

![图片描述](https://dn-simplecloud.shiyanlou.com/courses/uid1080331-20190603-1559571187150)

**单例模式的应用**

当你只需要一个实例对象的时候，就可以考虑使用单例模式。比如在资源共享的情况下，避免由于多个资源操作导致的性能或损耗等就可以使用单例模式。



## 2 心得

今天学习了设计模式中的装饰器模式，观察者模式和单例。

**明日计划**
Spring和github部分内容。